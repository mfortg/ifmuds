# -*- coding: utf-8 -*-
"""Maquina virtual.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ln42FcjcAmM6da5m_HL_ZFNQeRn0APDp
"""

# Para la practica

# import requests
# data = requests.get(url= 'https://randomuser.me/api')
# data = data.json()['results']

     # RETO predeterminadamente solo me pasa una persona necesito 100

import matplotlib.pyplot as plt
import seaborn as sns
import requests
import pandas as pd
import numpy as np

data = requests.get(url= 'https://randomuser.me/api/?results=100')
data = data.json()['results']

graph_path = '/home/marc/Desktop/MUDS'

print(data)

len(data)



# Convierte los datos en DataFrame
df = pd.json_normalize(data)

print(df.head())

for column in df:
    print(column)



# gender, dob_age/registered.age, location.country, country vs nat

df = df.drop(columns=['email', 'phone', 'cell', 'picture.large', 'picture.medium', 'picture.thumbnail'])

df['nat'].head()



df['dob.age'] # edad del usuario

df['registered.age'] # tiempo que lleva registrado

# CREAR ESTADISTICAS



"""Figura 1: Comparación por sexo"""

order = df['gender'].value_counts().index
plt.figure(figsize = (8,6))
ax = sns.countplot(data=df, x=df['gender'], hue= df['gender'], order = order)

plt.show()

plt.savefig(f'{graph_path}/gender.png', format='png', dpi = 300)
plt.close()



"""Comparación entre migrantes vs no migrantes"""

def swap_nat(sigla):
  paises = {
        "AU": "Australia",
        "BR": "Brazil",
        "CA": "Canada",
        "CH": "Switzerland",
        "DE": "Germany",
        "DK": "Denmark",
        "ES": "Spain",
        "FI": "Finland",
        "FR": "France",
        "GB": "United Kingdom",
        "IE": "Ireland",
        "IN": "India",
        "IR": "Iran",
        "MX": "Mexico",
        "NL": "Netherlands",
        "NO": "Norway",
        "NZ": "New Zealand",
        "RS": "Serbia",
        "TR": "Turkey",
        "UA": "Ukraine",
        "US": "United States"
  }
  return paises.get(str(sigla).upper())



df['nat']= df['nat'].apply(swap_nat)
 df.head()

# Se toma de referencia país(ESPAÑA) y hacer cuadro de localización nat

# location.country vs nat
# Crea la columna 'cambio' con la condición
df['cambio'] = np.where(df['nat'] == df['location.country'], 'Sí', 'No')

no_count = df['cambio'].value_counts().get('No', 0)   # NOS DA 100% de NO (corregir nat para que este nombre completo!!!!)
print("Número de 'No':", no_count)

"""Analisis por zona horaria"""

#location.timezone.offset

offsets_raw: list[str] = []
offsets: list[float] = []

for user in data:
  offsets_raw.append(user['location']['timezone']['offset'])

print(offsets_raw)
#los offsets están en formato str, hace falta convertirlos a valores numéricos
def convert_offset(offset):
  #el resto de la función se rompe con offset 0:00 ya que no tiene signo, asi que le añadiremos un signo +
  if offset == '0:00':
    offset = '+0:00'

  #todos los offset empiezan con un signo, si es - lo asignaremos como -1 y sino lo asignaremos como 1
  if offset[0] == '-':
    sign = -1
  else:
    sign = 1

  #tomamos el offset (ignorando el simbolo con el [1:]) y lo partimos por los : convirtiendolos en int (la funcion map aplica int a todos los iterables)
  hours, minutes = map(int, offset[1:].split(':'))

  #calculamos las horas de offset en valor numérico (IMPORTANTE: Multiplicadas por el valor acorde al signo para diferenciar entre negativo y posiivo)
  offset_hours = sign * (hours + (minutes / 60))
  return offset_hours

for offset in offsets_raw:
  offsets.append(convert_offset(offset))

print(offsets)

offset_counts = {}

#Vamos a contar las ocurrencias en intervalos de 3 horas
for offset in offsets:

    # Redondeamos al intervalo de 3 horas
    rounded_offset = round(offset / 3) * 3

    #Contamos las veces que ocurre un offset en cada intervalo, y lo inicializamos como 1 si es la primera vez
    if rounded_offset in offset_counts:
        offset_counts[rounded_offset] += 1
    else:
        offset_counts[rounded_offset] = 1

#ordenamos offset_counts para que este ordenado según sus keys (esto es para ordenar el gráfico fácilmente)
offset_counts = dict(sorted(offset_counts.items()))

#Creamos el gráfico
#Creamos las etiquetas usando las keys en el diccionario offset_counts
labels = [f"{key} horas" for key in offset_counts.keys()]
#Asignamos los valores de cada sección del gráfico (con el valor correspondiente a cada key del diccionario)
sizes = list(offset_counts.values())
#Generamos tantos colores (el Paired hace que sean colores distintso con una funcion de plt) como labels tenemos
colors = plt.cm.Paired(range(len(labels)))  # Generate a color map

#Tamaño del gráfico
plt.figure(figsize=(8, 6))
#Tipo de grafico(pie), los valores de cada sección (sizes), las etiquetas (labels), los colores (colors), el formato de decimales (autopct % = especificación de formato, 1.1 = minimo 1 número y un decimal, f = float), y startangle para que empiece bien alineado
plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
#Título
plt.title("Distribución de gente según su offset horario en intervalos de 3 horas")
#Ratio (igual para que sea circular)
plt.axis('equal')
plt.show()

plt.savefig(f'{graph_path}/offset.png', format='png', dpi = 300)

"""Histograma edad"""

# Histograma tiempo que lleva registrado

df['registered.age']  # Histograma
sns.histplot(data = df['registered.age'], bins=10, edgecolor = 'black')
plt.title('Antiguedad del Usuario')
plt.show()
plt.savefig(f'{graph_path}/userage.png', format='png', dpi = 300)



# Histograma Edad de los participantes

plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='dob.age')
plt.title("Distribución Edad")
plt.xlabel("Edad")
plt.show()
plt.savefig(f'{graph_path}/agedistribution.png', format='png', dpi = 300)
# en este caso no hay outliers???

# Transformar nombre países





"""Numero de usuarios registrados por año"""

# Crear columna, año, mes,día.  registered.date
df['registered.date'].head()

df['registered.date'] = pd.to_datetime(df['registered.date'])

df['year'] = df['registered.date'].dt.year

# # Extrae solo la parte de la fecha (año-mes-día)
# df['registered.date'] = df['registered.date'].dt.date

# # Muestra las primeras filas para verificar
df['year'].head()

df['year'].unique()

year_counts = df['year'].value_counts().sort_index()

# Crea un gráfico de línea
plt.figure(figsize=(10, 6))
plt.plot(year_counts.index, year_counts.values, marker='o', linestyle='-', color='skyblue', linewidth=2)
plt.xlabel("Año")
plt.ylabel("Conteo")
plt.title("Cantidad de registros por año")
plt.xticks(year_counts.index, year_counts.index.astype(int), rotation=45)  # Forzar años como enteros en el eje X
plt.grid(visible=True, linestyle='--', alpha=0.7)
plt.show()
plt.savefig(f'{graph_path}/registrosporaño.png', format='png', dpi = 300)

"""Media de edad de los usuarios registrados por primera vez

"""

#df['registered.date'].head()
df['dob.date'].head()

#registered.date - fecha de registro

#dob.date - fecha de nacimiento

# pendiente registered.date - dob.date
df['registered.date'] = pd.to_datetime(df['registered.date'])
df['dob.date'] = pd.to_datetime(df['dob.date'])

# Calcula la diferencia en años enteros
df['edad_registro'] = (df['registered.date'] - df['dob.date']).dt.days // 365

df['edad_registro'].head()

# edad_registro GROUP BY year (usar hue para agrupar)

# df['registered.year'] = df['registered.date'].dt.year

# Agrupa por año de registro y calcula la edad promedio



"""Conteo de los nombres más comunes"""

from collections import Counter   # para poder realizar el conteo

last_names = [user['name']['last'] for user in data]   # obtenemos los apellidos más comunes del listado extraído
name_counts = Counter(last_names)   # realizamos el conteo de los apellidos
common_last = name_counts.most_common(15)   # extraemos los apellidos más comunes
common_last

"""Conteo de las ciudades más comunes"""

city = [user['location']['city'] for user in data]   # extraemos el listado de ciudades
city_counts = Counter(city)   # realizamos el conteo de ciudades
top_cities = city_counts.most_common(3)   # nos quedamos con el top 3 de ciudades más comunes
top_cities

"""Hisograma de la distribución en función del mes de nacimiento"""

# Extraemos el listado de fechas, quedándonos solo con la posición de los meses
# aquí estamos asumiendo que la posición del mes es siempre la misma en todas las fechas
month_user = [user['dob']['date'][5:7] for user in data]
month_counts = Counter(month_user)   # realizamos el conteo de meses

# Lo pasamos a una tupla y ordenamos por meses, de menor a mayor
month_counts = dict(sorted(month_counts.items(), key=lambda item: item[0]))

# para pasar del número de mes al nombre del mes
month_names = {   # definimos los nombres de los meses
    '01': 'Enero',
    '02': 'Febrero',
    '03': 'Marzo',
    '04': 'Abril',
    '05': 'Mayo',
    '06': 'Junio',
    '07': 'Julio',
    '08': 'Agosto',
    '09': 'Septiembre',
    '10': 'Octubre',
    '11': 'Noviembre',
    '12': 'Diciembre',
}
month_number = list(month_counts.keys())   # obtenemos los números de los meses
month_labels = [month_names[m] for m in month_number]   # convertimos los números de mes a nombre
counts_born = list(month_counts.values())   # obtenemos los conteos de los meses

month_counts   # visualizamos los conteos por mes

# Visualizamos los datos en un gráfico
plt.figure()
plt.bar(month_labels, counts_born)
plt.xlabel('Meses')
plt.ylabel('Frecuencia')
plt.title('Distriución por mes de nacimiento')
plt.xticks(rotation=45)
plt.show()